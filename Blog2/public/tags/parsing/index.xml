<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>parsing on The R Blog</title>
    <link>https://blog.r-project.org/tags/parsing/</link>
    <description>Recent content in parsing on The R Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 30 Aug 2024 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://blog.r-project.org/tags/parsing/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Long input lines</title>
      <link>https://blog.r-project.org/2024/08/30/long-input-lines/</link>
      <pubDate>Fri, 30 Aug 2024 00:00:00 +0000</pubDate>
      
      <guid>https://blog.r-project.org/2024/08/30/long-input-lines/</guid>
      <description>When using R interactively via a console, one edits a line of input, confirms it by pressing ENTER, then R parses the line, evaluates it, prints the output and lets the user enter another line. This is also known as REPL (Read-Eval-Print-Loop).
The maximum length of the input line is sometimes limited. It is essentially impossible that one would run into a limit when typing the commands, but there was a report from a user who pasted generated content to the console and have ran into a limit of 4096 bytes.</description>
    </item>
    
    <item>
      <title>Parser Speedups</title>
      <link>https://blog.r-project.org/2019/01/07/parser-speedups/</link>
      <pubDate>Mon, 07 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://blog.r-project.org/2019/01/07/parser-speedups/</guid>
      <description>It wasn’t my primary goal to improve parser performance nor to measure it. I’ve been working on optimizations to reduce the runtime overhead of including source reference into packages (this is not done by default due to space and execution time overheads). I’ve added an option to exclude parse data from source references and enabled it by default for packages, as parse data account for most of the runtime overhead of source references while they are rarely needed.</description>
    </item>
    
    <item>
      <title>Unprotecting by Value</title>
      <link>https://blog.r-project.org/2018/12/10/unprotecting-by-value/</link>
      <pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.r-project.org/2018/12/10/unprotecting-by-value/</guid>
      <description>In short, UNPROTECT_PTR is dangerous and should not be used. This text describes why and describes how to replace it, including mset-based functions that have been introduced as a substitute for situations when unprotection by value is really needed. This could be of interest to anyone who writes native code to interface with the R heap, and definitely to all who use UNPROTECT_PTR in their code.
Background R provides several functions to protect pointers to R objects held by local C variables (typed SEXP) from the garbage collector.</description>
    </item>
    
  </channel>
</rss>